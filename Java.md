# Java

## 继承

> 继承的概念
>
> 继承在本职上是特殊——一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。通过 extends 关键字可以声明一个类是从另外一个类继承而来的。

### 1.2继承的特性

1. 子类拥有父类非`private`的属性，方法；
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；
3. 子类可以用自己的方式实现父类的方法；
4. Java的继承是单继承，这是Java继承区别于C++继承的一个特性；
5. 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。

###  1.3继承关键字

1. 使用 `extends` 和 `implements` 来实现继承，所有的类都是继承于 `java.lang.Object`，当一个类没有继承的两个关键字，则默认继承`Object`；
2. 一个子类只能拥有一个父类，所以 `extends` 只能继承一个类；
3. 使用 `implements` 关键字变相的使Java具有多继承的特性，为类继承接口，可以同时继承多个接口；
4. 通过`super`关键字来实现对父类成员的访问，用来引用当前对象的父类；
5.  `final `关键字
6.  声明类则把类定义为不能继承的，即最终类；修饰方法，则该方法不能被子类重写；定义实例变量，则变量不能被修改；
7. final 类的方法自动为 final方法，但实例变量不自动是 final变量。

## 重写

1. 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写;
2. 重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法;
3. 重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。

1. `1).参数列表必须完全与被重写方法的相同；`
2. `2).返回类型必须完全与被重写方法的返回类型相同；`
3. `3).访问权限不能比父类中被重写的方法的访问权限更低；`
4. `4).父类的成员方法只能被它的子类重写；`
5. `5).声明为final的方法不能被重写；`
6. `6).声明为static的方法不能被重写，但是能够被再次声明；`
7. `7).子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法；`
8. `8).子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法；`
9. `9).重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常，但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以；`
10. `10).构造方法不能被重写；`
11. `11).如果不能继承一个方法，则不能重写这个方法。`

## 重载

1. 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同；
2. 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

1. `1).被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；`
2. `2).被重载的方法可以改变返回类型；`
3. `3).被重载的方法可以改变访问修饰符；`
4. `4).被重载的方法可以声明新的或更广的检查异常；`
5. `5).方法能够在同一个类中或者在一个子类中被重载；`
6. `6).无法以返回值类型作为重载函数的区分标准。`

## 多态

> 多态就是同一个接口，使用不同的实例执行不同操作。
>
> 父类引用子类对象
>
> 多态的实现方式 重写、接口、抽象类和抽象方法。

### 多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象：**Parent p = new Child();**

## 抽象类

1. `1).使用abstract class来定义抽象类，抽象类不能被实例化；`
2. `2).抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；`
3. `3).抽象类中的抽象方法只是声明，不包含方法体；`
4. `4).构造方法，类方法（用static修饰的方法）不能声明为抽象方法；`
5. `5).任何子类必须重写父类的抽象方法，或者声明自身为抽象类。`

## 封装

> 封装（英语：Encapsulation）是指，一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。

封装的优点

1. `1).良好的封装能够减少耦合；`
2. `2).类内部的结构可以自由修改；`
3. `3). 可以对成员变量进行更精确的控制；`
4. `4). 隐藏信息，实现细节。`

## 接口

1. `1).接口，在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明；`
2. `2).一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；`
3. `3).接口不能包含成员变量，除了 static 和 final 变量；`
4. `4).接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract；`
5. `5).接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量；`
6. `6).接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法；`
7. `7).类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常；`
8. `8).类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；`
9. `9).接口的继承使用extends关键字,允许多重继承,可能定义或继承相同的方法。`

## Entry

由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。

Map中采用**Entry内部类**来表示一个映射项，映射项包含Key和Value（我们总说键值对，每一个键值对也就是一个Entry）

Map.Entry里面包含getKey()和getValue()方法

```java
Iterator<Map.Entry<Integer, Integer>> it=map.entrySet().iterator();
    while(it.hasNext()) {
        Map.Entry<Integer,Integer> entry=it.next();
        int key=entry.getKey();
        int value=entry.getValue();
        System.out.println(key+" "+value);
    }
```

## entrySet

entrySet是java中 键-值对的集合，Set里面的类型是Map.Entry，一般可以通过map.entrySet()得到。

- entrySet实现**Set接口**，里面存放的是键值对。一个K对应一个V。

用来遍历map的一种方法。

```java
Set<Map.Entry<String, String>> entryseSet=map.entrySet();
 
for (Map.Entry<String, String> entry:entryseSet) {
 
    System.out.println(entry.getKey()+","+entry.getValue());
 
}
```

## String，StringBuffer，StringBuilder

| string                                                       | stringBuffer                                                 | stringBuilder    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- |
| String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 | StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 | 可变类，速度更快 |
| 不可变                                                       | 可变                                                         | 可变             |
|                                                              | 线程安全                                                     | 线程不安全       |
|                                                              | 多线程操作字符串                                             | 单线程操作字符串 |

## 多线程的创建

继承`Thread`类

1. 定义一个类MyThread继承Thread
2. 在MyThread类中重写run方法
3. 创建MyThread类的对象
4. 启动线程
